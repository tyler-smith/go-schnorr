package schnorr

import (
	"encoding/hex"
	"fmt"
	"testing"

	"github.com/gcash/bchd/bchec"
)

func TestSchnorrEndToEnd(t *testing.T) {
	privkey, err := bchec.NewPrivateKey(curve)
	if err != nil {
		t.Fatal(err)
	}

	pubkey := privkey.PubKey()

	msg := []byte("Hello, World!")

	sig := Sign(privkey, pubkey, msg)

	fmt.Println(sig)

	err = Verify(pubkey, sig, msg)
	if err != nil {
		fmt.Println("Signature failed to verify:", err)
		return
	}

	fmt.Println("Signature verified correctly")
}

func TestSchnorrVectors(t *testing.T) {
	pkBuff := []byte{
		0x02,
		0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC,
		0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B, 0x07,
		0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28, 0xD9,
		0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17, 0x98,
	}

	msg := []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	sigBuff := []byte{
		0x78, 0x7A, 0x84, 0x8E, 0x71, 0x04, 0x3D, 0x28,
		0x0C, 0x50, 0x47, 0x0E, 0x8E, 0x15, 0x32, 0xB2,
		0xDD, 0x5D, 0x20, 0xEE, 0x91, 0x2A, 0x45, 0xDB,
		0xDD, 0x2B, 0xD1, 0xDF, 0xBF, 0x18, 0x7E, 0xF6,
		0x70, 0x31, 0xA9, 0x88, 0x31, 0x85, 0x9D, 0xC3,
		0x4D, 0xFF, 0xEE, 0xDD, 0xA8, 0x68, 0x31, 0x84,
		0x2C, 0xCD, 0x00, 0x79, 0xE1, 0xF9, 0x2A, 0xF1,
		0x77, 0xF7, 0xF2, 0x2C, 0xC1, 0xDC, 0xED, 0x05,
	}

	privkey, pubkey := bchec.PrivKeyFromBytes(curve, pkBuff)

	sig := Sign(privkey, pubkey, msg)

	// fmt.Println(sig)

	if sig.String() != hex.EncodeToString(sigBuff) {
		t.Fatal("Incorrect sig. Wanted:", hex.EncodeToString(sigBuff), "Got:", sig.String())
	}

	// err = Verify(pubkey, sig, msg)
	// if err != nil {
	// 	fmt.Println("Signature failed to verify:", err)
	// 	return
	// }

	// fmt.Println("Signature verified correctly")
}
